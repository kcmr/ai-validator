name: Validate Instructions With Agent

on:
  issue_comment:
    types:
      - created

jobs:
  run-agent:
    if: >-
      github.event.issue.pull_request != null &&
      startsWith(github.event.comment.body, '/validate') &&
      github.event.comment.user.login == 'kcmr'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      models: read
      issues: write
      pull-requests: write
      actions: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install uv
        run: python -m pip install --upgrade uv

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Sync agent dependencies
        working-directory: agent
        run: uv sync --no-dev

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-browsers-${{ runner.os }}-chromium
          restore-keys: |
            playwright-browsers-${{ runner.os }}-

      - name: Check cache status
        run: |
          if [ "${{ steps.playwright-cache.outputs.cache-hit }}" = "true" ]; then
            echo "‚úÖ Cache hit: Playwright browsers restored from cache"
            ls -la ~/.cache/ms-playwright/ || echo "Cache directory exists but is empty"
          else
            echo "‚ùå Cache miss: Browsers will be downloaded"
          fi

      - name: Install Playwright browsers
        working-directory: agent
        run: npx playwright install chromium --only-shell

      - name: Prepare prompt from comment
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          python <<'PY'
          import os
          from pathlib import Path

          comment = os.environ.get("COMMENT_BODY", "").strip()
          trigger = "/validate"
          prompt = comment[len(trigger):].strip() if comment.startswith(trigger) else comment

          Path("agent_prompt.txt").write_text(prompt, encoding="utf-8")

          github_env_path = os.environ["GITHUB_ENV"]
          with open(github_env_path, "a", encoding="utf-8") as env_file:
              env_file.write("PROMPT<<EOF\n")
              env_file.write(prompt)
              env_file.write("\nEOF\n")
          PY

      - name: Run agent
        working-directory: agent
        continue-on-error: true
        env:
          PROMPT: ${{ env.PROMPT }}
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          LLM_BASE_URL: ${{ vars.LLM_BASE_URL || 'https://models.github.ai/inference' }}
          LLM_MODEL_NAME: ${{ vars.LLM_MODEL_NAME || 'openai/gpt-4o-mini' }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          uv run ai-validator-agent "$PROMPT" 2>&1 | tee ../agent_output.txt || echo "Agent execution failed" >> ../agent_output.txt

      - name: Publish playwright report artifact
        id: upload-artifact
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: agent/playwright-report/

      - name: Parse agent output
        id: parse-output
        run: |
          # Read the agent output
          if [ ! -f agent_output.txt ]; then
            echo "status=unknown" >> $GITHUB_OUTPUT
            echo "details=No output file found" >> $GITHUB_OUTPUT
            echo "processed_output=## Test Results\n\n**Status:** ‚ùì Unknown\n\nNo output was captured from the agent execution." >> $GITHUB_OUTPUT
            exit 0
          fi

          RAW_OUTPUT=$(cat agent_output.txt)

          # Extract JSON more precisely - look for the last complete JSON object with status and details
          # This helps avoid capturing JSON from dependency installations or other tools
          JSON_OUTPUT=$(echo "$RAW_OUTPUT" | grep -o '{[^{}]*"status"[^{}]*"details"[^{}]*}' | tail -1 || echo "")

          # If no simple JSON found, try multi-line JSON extraction
          if [ -z "$JSON_OUTPUT" ]; then
            # Look for JSON blocks that span multiple lines, focusing on the agent's structured output
            JSON_OUTPUT=$(echo "$RAW_OUTPUT" | sed -n '/^{$/,/^}$/p' | grep -A 20 -B 5 '"status"' | grep -A 20 -B 5 '"details"' | head -50 | jq -s '.[0] // empty' 2>/dev/null || echo "")
          fi

          if [ -n "$JSON_OUTPUT" ] && echo "$JSON_OUTPUT" | jq . >/dev/null 2>&1; then
            # Successfully parsed JSON
            STATUS=$(echo "$JSON_OUTPUT" | jq -r '.status // "unknown"')
            DETAILS=$(echo "$JSON_OUTPUT" | jq -r '.details // "No details available"')
            
            # Format the processed output
            if [ "$STATUS" = "success" ]; then
              STATUS_TEXT="‚úÖ Success"
            elif [ "$STATUS" = "failure" ]; then
              STATUS_TEXT="‚ùå Failure"
            else
              STATUS_TEXT="‚ùì Unknown"
            fi
            
            PROCESSED_OUTPUT="## Test Results\n\n**Status:** $STATUS_TEXT\n\n$DETAILS"
          else
            # No valid JSON found - show a clean error message
            STATUS="parse_error"
            DETAILS="Could not extract structured test results from agent output"
            PROCESSED_OUTPUT="## Test Results\n\n**Status:** ‚ùå Parse Error\n\nCould not extract structured test results from agent output. Please check that the agent is returning valid JSON with 'status' and 'details' fields."
          fi

          # Set outputs
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "details<<EOF" >> $GITHUB_OUTPUT
          echo -e "$DETAILS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "processed_output<<EOF" >> $GITHUB_OUTPUT
          echo -e "$PROCESSED_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Comment PR with agent output
        uses: actions/github-script@v7
        env:
          PROMPT: ${{ env.PROMPT }}
          ARTIFACT_URL: ${{ steps.upload-artifact.outputs.artifact-url }}
          TEST_STATUS: ${{ steps.parse-output.outputs.status }}
          PROCESSED_OUTPUT: ${{ steps.parse-output.outputs.processed_output }}
        with:
          script: |
            // Get the artifact URL from the upload step
            const artifactUrl = process.env.ARTIFACT_URL;
            let artifactLink = `[workflow artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`;

            if (artifactUrl) {
              artifactLink = `[playwright-report artifact](${artifactUrl})`;
            }

            // Get status emoji based on test result
            const testStatus = process.env.TEST_STATUS || 'unknown';
            const statusEmoji = testStatus === 'success' ? '‚úÖ' : testStatus === 'failure' ? '‚ùå' : 'ü§ñ';

            // Create the comment body with processed output from jq
            const commentBody = `## ${statusEmoji} AI Validator Agent Results

            **Prompt:** \`${process.env.PROMPT || 'Not available'}\`

            ${process.env.PROCESSED_OUTPUT}

            ### üìπ Video Report
            A video recording of the validation process has been generated. You can download it from the ${artifactLink}.

            ---
            *This comment was generated automatically by the AI Validator Agent workflow.*`;

            // Look for existing workflow comments
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            // Find existing AI Validator Agent comment
            const botComment = comments.data.find(comment => 
              comment.body.includes('ü§ñ AI Validator Agent Results') &&
              comment.body.includes('*This comment was generated automatically by the AI Validator Agent workflow.*')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                comment_id: botComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
              console.log(`Updated existing comment ID: ${botComment.id}`);
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
              console.log('Created new comment');
            }
