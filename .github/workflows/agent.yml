name: Validate Instructions With Agent

on:
  issue_comment:
    types:
      - created

jobs:
  run-agent:
    if: >-
      github.event.issue.pull_request != null &&
      startsWith(github.event.comment.body, '/validate') &&
      github.event.comment.user.login == 'kcmr'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      models: read
      issues: write
      pull-requests: write
      actions: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Setup uv with cache
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: true
          cache-dependency-glob: "agent/uv.lock"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Sync agent dependencies
        working-directory: agent
        run: uv sync --no-dev

      - name: Restore Playwright browsers cache
        uses: actions/cache/restore@v4
        id: playwright-cache-restore
        with:
          path: ~/.cache/ms-playwright
          key: playwright-browsers-${{ runner.os }}-chromium
          restore-keys: |
            playwright-browsers-${{ runner.os }}-

      - name: Install Playwright browsers
        if: steps.playwright-cache-restore.outputs.cache-hit != 'true'
        working-directory: agent
        run: |
          echo "ðŸ“¥ Installing Playwright browsers..."
          npx playwright install chromium --with-deps

      - name: Save Playwright browsers cache
        if: steps.playwright-cache-restore.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-browsers-${{ runner.os }}-chromium

      - name: Prepare prompt from comment
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        working-directory: agent
        run: |
          python <<'PY'
          import os
          import sys
          from pathlib import Path

          # Get comment body from environment
          comment = os.environ.get("COMMENT_BODY", "").strip()
          if not comment:
              print("ERROR: No comment body found", file=sys.stderr)
              sys.exit(1)

          # Extract prompt after /validate trigger
          trigger = "/validate"
          if not comment.startswith(trigger):
              print(f"ERROR: Comment does not start with '{trigger}'", file=sys.stderr)
              sys.exit(1)

          # Get prompt content after trigger, handling potential whitespace
          prompt = comment[len(trigger):].lstrip()
          if not prompt:
              print("ERROR: No prompt content found after trigger", file=sys.stderr)
              sys.exit(1)

          # Decode escape sequences properly (handle \n, \t, etc.)
          # This handles GitHub's text which may contain literal escape sequences
          try:
              # First try to decode as-is, then handle any literal escape sequences
              prompt_decoded = prompt.encode().decode('utf-8')
          except:
              prompt_decoded = prompt

          # Save prompt as markdown file in current directory
          prompt_file = Path("user_prompt.md")
          try:
              with open(prompt_file, "w", encoding="utf-8", newline="") as f:
                  f.write(prompt_decoded)
              print(f"âœ“ Prompt saved to {prompt_file.absolute()}")
              print(f"âœ“ Prompt size: {len(prompt_decoded)} bytes")
          except Exception as e:
              print(f"ERROR: Failed to save prompt file: {e}", file=sys.stderr)
              sys.exit(1)

          # Also set environment variable for reference in parent workflow
          github_env_path = os.environ.get("GITHUB_ENV", "")
          if github_env_path:
              with open(github_env_path, "a", encoding="utf-8") as env_file:
                  env_file.write("PROMPT<<EOF\n")
                  env_file.write(prompt_decoded)
                  env_file.write("\nEOF\n")
          PY

      - name: Run agent
        working-directory: agent
        continue-on-error: true
        env:
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          # Only used with GitHub Models
          LLM_MODEL_NAME: ${{ vars.LLM_MODEL_NAME || 'openai/gpt-4o-mini' }}
          LOGFIRE_TOKEN: ${{ secrets.LOGFIRE_TOKEN }}
          PLAYWRIGHT_BROWSERS_PATH: ~/.cache/ms-playwright
        run: |
          echo "ðŸš€ Starting AI validator agent..."
          uv run ai-validator-agent --file user_prompt.md 2>&1 | tee ../agent_output.txt || echo "Agent execution failed" >> ../agent_output.txt

      - name: Publish playwright report artifact
        id: upload-artifact
        uses: actions/upload-artifact@v4
        with:
          name: agent-reports
          path: agent/reports/

      - name: Parse agent output
        id: parse-output
        run: |
          # Read the result.json file generated by the agent
          RESULT_FILE="agent/reports/result.json"

          if [ ! -f "$RESULT_FILE" ]; then
            echo "status=no_result_file" >> $GITHUB_OUTPUT
            echo "details=Result file was not generated by the agent" >> $GITHUB_OUTPUT
            echo "processed_output=## Test Results\n\n**Status:** â“ Error\n\nThe result file (result.json) was not generated by the agent. Verify that the agent execution completed successfully." >> $GITHUB_OUTPUT
            exit 0
          fi

          # Parse the JSON result file
          JSON_OUTPUT=$(cat "$RESULT_FILE")

          if echo "$JSON_OUTPUT" | jq . >/dev/null 2>&1; then
            # Successfully parsed JSON
            STATUS=$(echo "$JSON_OUTPUT" | jq -r '.status // "unknown"')
            DETAILS=$(echo "$JSON_OUTPUT" | jq -r '.details // "No details available"')
            
            # Format the processed output
            if [ "$STATUS" = "success" ]; then
              STATUS_TEXT="âœ… Success"
            elif [ "$STATUS" = "failure" ]; then
              STATUS_TEXT="âŒ Failure"
            else
              STATUS_TEXT="â“ Unknown"
            fi
            
            PROCESSED_OUTPUT="## Test Results\n\n**Status:** $STATUS_TEXT\n\n$DETAILS"
          else
            # Invalid JSON in result file
            STATUS="invalid_json"
            DETAILS="The result.json file contains invalid JSON"
            PROCESSED_OUTPUT="## Test Results\n\n**Status:** âŒ Error\n\nThe result.json file generated by the agent contains invalid JSON."
          fi

          # Set outputs
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "details<<EOF" >> $GITHUB_OUTPUT
          echo -e "$DETAILS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "processed_output<<EOF" >> $GITHUB_OUTPUT
          echo -e "$PROCESSED_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Comment PR with agent output
        uses: actions/github-script@v7
        env:
          PROMPT: ${{ env.PROMPT }}
          ARTIFACT_URL: ${{ steps.upload-artifact.outputs.artifact-url }}
          TEST_STATUS: ${{ steps.parse-output.outputs.status }}
          PROCESSED_OUTPUT: ${{ steps.parse-output.outputs.processed_output }}
        with:
          script: |
            // Get the artifact URL from the upload step
            const artifactUrl = process.env.ARTIFACT_URL;
            let artifactLink = `[workflow artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})`;

            if (artifactUrl) {
              artifactLink = `[playwright-report artifact](${artifactUrl})`;
            }

            // Get status emoji based on test result
            const testStatus = process.env.TEST_STATUS || 'unknown';
            const statusEmoji = testStatus === 'success' ? 'âœ…' : testStatus === 'failure' ? 'âŒ' : 'ðŸ¤–';

            // Create the comment body with processed output from jq
            const commentBody = `## ${statusEmoji} AI Validator Agent Results

            **Prompt:** \`${process.env.PROMPT || 'Not available'}\`

            ${process.env.PROCESSED_OUTPUT}

            ### ðŸ“¹ Video Report
            A video recording of the validation process has been generated. You can download it from the ${artifactLink}.

            ---
            *This comment was generated automatically by the AI Validator Agent workflow.*`;

            // Look for existing workflow comments
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            // Find existing AI Validator Agent comment
            const botComment = comments.data.find(comment => 
              comment.body.includes('ðŸ¤– AI Validator Agent Results') &&
              comment.body.includes('*This comment was generated automatically by the AI Validator Agent workflow.*')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                comment_id: botComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
              console.log(`Updated existing comment ID: ${botComment.id}`);
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
              console.log('Created new comment');
            }
